<!DOCTYPE html><html lang="en-US" data-reactroot=""><head><title data-react-helmet="true"></title><link rel="stylesheet" href="https://g2graman.github.io/lessons-site-generator/styles.2d308331.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css"/><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:500"/></head><body><div class="slug-home"><div id="root"><div data-reactroot=""><header class=" mdc-toolbar"><div class=" mdc-toolbar__row"><section class="brand  mdc-toolbar__section mdc-toolbar__section--align-start"><svg width="48" height="48" viewBox="0 0 1205 863" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>white bridge logo</title><desc>white bridge logo</desc><use xlink:href="#a" transform="translate(0 485.01)" fill="#FAFAFA"></use><use xlink:href="#b" transform="translate(246.1 572.65)" fill="#FAFAFA"></use><use xlink:href="#c" transform="translate(412.5 486)" fill="#FAFAFA"></use><use xlink:href="#d" transform="translate(522.1 486)" fill="#FAFAFA"></use><use xlink:href="#e" transform="translate(768.2 573.64)" fill="#FAFAFA"></use><use xlink:href="#f" transform="translate(1013.3 573.64)" fill="#FAFAFA"></use><g><use xlink:href="#g" transform="translate(198.3 1)" fill="#FAFAFA"></use><use xlink:href="#h" transform="translate(859.9)" fill="#FAFAFA"></use><use xlink:href="#i" transform="translate(382.6)" fill="#FAFAFA"></use><use xlink:href="#j" transform="translate(381.6 106.56)" fill="#FAFAFA"></use></g><defs><path id="a" d="M57.792 297.776H0V0h57.792v110.546c8.967-10.955 29.892-21.91 50.816-21.91 59.785 0 92.666 48.799 92.666 107.557 0 58.759-33.878 106.562-92.666 106.562-21.92 0-42.845-10.955-50.816-21.91v16.931zm0-68.718c6.974 13.943 21.92 23.902 37.863 23.902 30.889 0 48.824-24.898 48.824-57.763 0-32.864-17.935-57.762-48.824-57.762-15.942 0-31.885 9.959-37.863 23.902v67.721z"></path><path id="b" d="M125.547 61.746c-7.971-4.98-17.935-6.971-28.895-6.971-18.932 0-34.875 9.959-39.857 28.881v126.48H0V4.98h56.795v19.918C65.763 9.959 82.702 0 102.63 0c9.964 0 17.935 1.992 21.921 2.988l.996 58.758z"></path><path id="c" d="M33.878 65.73C15.943 65.73 0 52.783 0 32.865 0 14.939 14.946 0 33.878 0c17.935 0 33.878 12.947 33.878 32.865-.997 19.918-16.94 32.865-33.878 32.865zm27.9 231.05H4.981V92.62h56.795v204.16z"></path><path id="d" d="M143.483 279.849c-8.968 10.955-29.893 21.91-50.817 21.91C32.88 301.759 0 253.956 0 195.197 0 136.439 33.878 87.64 92.666 87.64c21.921 0 42.845 10.955 50.817 21.91V0h57.791v297.776h-57.791v-17.927zm0-118.512c-6.975-12.947-21.921-23.902-37.864-23.902-30.888 0-48.824 24.897-48.824 57.762s17.936 57.763 48.824 57.763c16.939 0 31.885-9.959 37.864-23.902v-67.721z"></path><path id="e" d="M142.486 184.242c-8.967 10.955-27.899 20.914-49.82 20.914C32.882 205.156 0 157.353 0 102.578 0 47.803 33.878 0 92.666 0c22.917 0 40.853 9.959 49.82 19.918V3.984h56.795v182.25c0 69.714-42.845 102.578-100.637 102.578-52.81 0-89.676-26.889-95.655-72.701h54.803c4.982 18.923 17.935 28.882 39.856 28.882 28.896 0 43.842-16.931 43.842-49.796l.996-10.955zm0-115.524c-6.975-11.951-21.921-20.915-37.863-20.915-30.889 0-47.828 22.906-47.828 54.775s17.936 54.775 47.828 54.775c16.939 0 31.885-9.959 37.863-21.91V68.717z"></path><path id="f" d="M190.314 142.414c-7.972 42.824-39.857 71.706-90.673 71.706C39.856 214.12 0 171.296 0 107.558 0 44.816 40.853 0 98.644 0c60.781 0 92.666 40.832 92.666 101.582v16.931H54.802c1.993 30.873 18.932 48.799 43.842 48.799 18.932 0 33.878-7.967 37.864-25.893l53.806.995zM56.795 84.652h78.716c0-21.91-12.953-37.844-36.867-37.844-21.92 0-37.863 12.946-41.849 37.844z"></path><path id="g" d="M85.69 302.755c0 8.963 4.983 13.943 13.95 13.943h46.832v42.824H99.641c-36.867 0-62.774-23.902-62.774-60.75V214.12c0-8.964-4.982-13.943-13.95-13.943H0v-43.82h23.914c8.967 0 13.95-4.979 13.95-13.943V60.75C37.863 22.906 63.77 0 100.636 0h45.835v42.824H99.641c-8.968 0-13.95 4.98-13.95 13.943v80.668c0 20.914-9.964 31.869-22.917 39.836 12.953 7.967 22.917 18.922 22.917 39.836v85.648z"></path><path id="h" d="M60.78 217.107c0-20.914 9.965-31.869 22.918-39.836-12.953-7.967-22.917-18.922-22.917-39.836V55.771c0-8.963-4.982-13.943-13.95-13.943H0V0h45.835c36.867 0 62.773 23.902 62.773 60.75v79.673c0 8.963 4.982 13.942 13.95 13.942h23.914v44.816h-23.914c-8.968 0-13.95 4.98-13.95 13.943v84.652c0 37.844-25.906 60.75-62.773 60.75H0v-42.824h46.831c8.968 0 13.95-4.98 13.95-13.943v-84.652z"></path><path id="i" d="M220.206 0H0v41.828H439.415V0H220.206z"></path><path id="j" d="M374.649 210.136v-59.754C374.649 65.73 307.89 0 222.199 0h-3.986c-85.691 0-152.45 65.73-152.45 150.382v59.754H0v42.824h107.612V151.378c0-60.75 48.824-108.554 110.601-108.554h3.986c61.777 0 110.601 47.803 110.601 108.554V252.96h107.612v-42.824h-65.763z"></path></defs></svg></section><section class="navigation  mdc-toolbar__section"><nav><a href="https://g2graman.github.io/lessons-site-generator/">Modules</a><a href="https://g2graman.github.io/lessons-site-generator/about">About</a></nav></section></div></header><div class="content"><div><a href="https://g2graman.github.io/lessons-site-generator/"><button class=" mdc-button mdc-button--stroked">Back to Modules</button></a><br/><h3>Observables Intro</h3><p><h1 id="observables-introduction">Observables: introduction</h1>
<p>Since JavaScript is single-threaded, we often run into situations that involve asynchronous data flows.</p>
<h2 id="what-are-asynchronous-data-flows-again-">What are asynchronous data flows again?</h2>
<p>Data from functions that are processed in their own time, where the results will arrive outside the regular flow of the app. </p>
<p>For example, we often see this in the context of API calls when we request data from another server or backend service. We make a request for the data on the side and, once the data arrives, we put it in a queue to be processed. We don&#39;t actually stop and hold up all activity in the app until the data comes back. Instead, we put it to the side and process it when it arrives (and when we&#39;re ready) - [<em>insert link to event loop bridge content here</em>].</p>
<p>We also encounter this with DOM events, timer intervals, web workers and web sockets.</p>
<p><strong>Don&#39;t we already have a few ways to handle asynchronous data?</strong> 
Yes, we can use callback functions and promises for example. But Observables are slightly different as they allow us to process <strong>streams of data</strong>.</p>
<h2 id="why-should-i-care-">Why should I care?</h2>
<p>Observables play a key part in something called <strong>reactive programming</strong>. This is the concept of programming with asynchronous data streams (a sequence of values in time). You can choose to listen to these streams and, as data comes through them, react accordingly. </p>
<p>Data streams are functional - so you can use streams as inputs into other streams, combine them, filter them, etc using a variety of helpful functions. </p>
<p>Angular has Observables baked into core parts of its library, such as its event system and HTTP client service, using a third-party library called RxJS (Reactive Extensions). In addition, we&#39;re starting to see more React projects use RxJS to take advantage of Observables to manage streams.</p>
<h2 id="what-is-an-observable-">What is an Observable?</h2>
<p>Observables originate from something called the <strong>observer design pattern</strong>. </p>
<blockquote>
<p>The observer pattern is a software design pattern in which an object, called the <strong>subject</strong>, maintains a list of its dependents, called <strong>observers</strong>, and notifies them automatically of any state changes, usually by calling one of their methods. (<a href="https://en.wikipedia.org/wiki/Observer_pattern">source</a>) </p>
</blockquote>
<p>Ok, so that definition is pretty wordy and technical. </p>
<p>In simple terms, the pattern involves an object (called an observable) that will share (or emit) data as it arrives over time. Throughout your code, many different objects (called observers) can sign up to be notified when that data arrives (called subscribing). So, whenever our observable recieves its data, it will broadcast that information out and the observers will be listening for it.  </p>
<p>Some key points to note about the pattern:</p>
<ul>
<li>You can have one observable and many observers (a one-to-many dependancy). That is, one broadcaster and an unlimited number of recipients.</li>
<li>When that observable changes, all observers should be updated/notified immediately and automatically</li>
<li>It is the observer&#39;s responsibility to register and unregister themselves from the observable (to be notified of changes) and to update their own state when notified.</li>
</ul>
<h2 id="so-an-observable-">So... an Observable?</h2>
<p>Think of an observable as a box that you create to hold data from a service or function whose data or items will arrive over time. </p>
<p>As the data arrives, the box notifies anyone that has requested they be updated and it does so in the way they&#39;ve asked.</p>
<h2 id="basic-structure">Basic structure</h2>
<p>In its simpliest form, an Observable is a function that accepts an object (an observer) with next, error and complete methods on it. </p>
<p>When you create an observable, you call its constructor and pass in a function. That function takes in an observer as a parameter and its body contains instructions for when to call each of the observer&#39;s methods. </p>
<p>For example:</p>
<pre><code class="lang-javascript">const data = Observable.create(observer =&gt; {
  setTimeout(() =&gt; observer.next(&#39;first&#39;), 1000);
  setTimeout(() =&gt; observer.complete(), 3000);
});
</code></pre>
<p>The newly created observable doesn&#39;t actually do anything until: </p>
<ul>
<li>a) someone subscribes and passes in an observer and </li>
<li>b) data is emitted.</li>
</ul>
<p>When you subscribe to an observable, this is the equivilant to calling the observable like a function and passing in an observer. This tells the observerable that you&#39;d like to be notified when data arrives, and tells it which functions to run (via the observer object) to do that.</p>
<pre><code class="lang-javascript">this.data
    .subscribe({
        next: console.log,
        error: console.error,
        complete: () =&gt; console.info(&#39;complete&#39;)
    });
</code></pre>
<p>Our observer contains 1 to 3 functions to be executed by the observable:</p>
<ul>
<li>next: function that will be executed each time a value is emitted (mandatory) </li>
<li>error: function that will be executed when an error is emitted (optional)</li>
<li><p>complete: function that will be executed when a &#39;completed&#39; is emitted (optional)</p>
<p>```javascript
this.data
 .subscribe(myObserver);</p>
</li>
</ul>
<p>const myObserver = {
    next: console.log,
    error: console.error,
    complete: () =&gt; console.info(&#39;complete&#39;)
}
```</p>
<p>Those functions you pass in as part of the observer object will stay active and listen for those events until you manually decide to unsubscribe from and stop listening to the observable.</p>
<p>Note: <code>error</code> and <code>complete</code> are optional. But when these functions are called, they will trigger the unsubscription logic and the observer will stop listening to the observable. So if there is an error, the complete won&#39;t fire and vice versa.</p>
<p>When you subscribe, the observable sets up your observer with the functions you pass in and, when it emits, it&#39;ll call those functions.</p>
<h2 id="basic-example">Basic example</h2>
<p><a href="https://jsbin.com/penicovixi/edit?js,console">Open in JSbin</a></p>
<p><em>(example by Philip Da Silva)</em></p>
<h2 id="how-do-observables-compare-">How do Observables compare?</h2>
<p>Callbacks:</p>
<ul>
<li>Not as scalable and they often can become overly nested (pyramid of doom)</li>
</ul>
<p>Promises:</p>
<ul>
<li>Good for one piece of data but they aren&#39;t as helpful for managing collections of data over time. For example, when you expect one value from a server and then for that promise to be fulfilled. </li>
<li>They also aren&#39;t cancellable - they are always listening.</li>
</ul>
<p>Observables:</p>
<ul>
<li>Allow us to work with complex data over time (streams)</li>
<li>Are cancellable</li>
<li>Are compositional (you can build on them) and they are lazy (they do not start emitting data until an observer has subscribed)</li>
<li>Allows us to chain together array-like operators and pass observable streams through to parse, modify and maintain the data within them. We&#39;ll look at these next.</li>
</ul>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&#39;ve been missing</a></li>
<li><a href="https://xgrommx.github.io/rx-book/why_rx.html">RxBook</a></li>
<li><a href="https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87">Learning Observable By Building Observable</a></li>
<li><a href="https://developer.telerik.com/topics/web-development/introduction-observables-angular-developers/">An Introduction to Observables for Angular Developers</a></li>
<li><a href="https://angular-2-training-book.rangle.io/handout/observables/">Angular 2 Training: Observables</a></li>
<li><a href="https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339">Hot vs Cold Observables</a></li>
<li><a href="http://blog.rangle.io/observables-and-reactive-programming-in-angular-2/">Observables and Reactive Programming in Angular 2</a></li>
<li><a href="https://www.learnrxjs.io/">Learn RxJS</a></li>
<li><a href="http://reactivex.io/rxjs/">RxJS</a></li>
</ul>
</p></div></div></div></div></div><script type="text/javascript">
                window.__routeData = {"path":"/modules/4-Observables/observables-intro","propsMap":{"__local":"Z1zqb8m"},"initialProps":{"module":{"contents":{"data":{}},"title":"Observables Intro","path":"4-Observables/observables-intro","id":"observables-intro","body":"<h1 id=\"observables-introduction\">Observables: introduction</h1>\n<p>Since JavaScript is single-threaded, we often run into situations that involve asynchronous data flows.</p>\n<h2 id=\"what-are-asynchronous-data-flows-again-\">What are asynchronous data flows again?</h2>\n<p>Data from functions that are processed in their own time, where the results will arrive outside the regular flow of the app. </p>\n<p>For example, we often see this in the context of API calls when we request data from another server or backend service. We make a request for the data on the side and, once the data arrives, we put it in a queue to be processed. We don&#39;t actually stop and hold up all activity in the app until the data comes back. Instead, we put it to the side and process it when it arrives (and when we&#39;re ready) - [<em>insert link to event loop bridge content here</em>].</p>\n<p>We also encounter this with DOM events, timer intervals, web workers and web sockets.</p>\n<p><strong>Don&#39;t we already have a few ways to handle asynchronous data?</strong> \nYes, we can use callback functions and promises for example. But Observables are slightly different as they allow us to process <strong>streams of data</strong>.</p>\n<h2 id=\"why-should-i-care-\">Why should I care?</h2>\n<p>Observables play a key part in something called <strong>reactive programming</strong>. This is the concept of programming with asynchronous data streams (a sequence of values in time). You can choose to listen to these streams and, as data comes through them, react accordingly. </p>\n<p>Data streams are functional - so you can use streams as inputs into other streams, combine them, filter them, etc using a variety of helpful functions. </p>\n<p>Angular has Observables baked into core parts of its library, such as its event system and HTTP client service, using a third-party library called RxJS (Reactive Extensions). In addition, we&#39;re starting to see more React projects use RxJS to take advantage of Observables to manage streams.</p>\n<h2 id=\"what-is-an-observable-\">What is an Observable?</h2>\n<p>Observables originate from something called the <strong>observer design pattern</strong>. </p>\n<blockquote>\n<p>The observer pattern is a software design pattern in which an object, called the <strong>subject</strong>, maintains a list of its dependents, called <strong>observers</strong>, and notifies them automatically of any state changes, usually by calling one of their methods. (<a href=\"https://en.wikipedia.org/wiki/Observer_pattern\">source</a>) </p>\n</blockquote>\n<p>Ok, so that definition is pretty wordy and technical. </p>\n<p>In simple terms, the pattern involves an object (called an observable) that will share (or emit) data as it arrives over time. Throughout your code, many different objects (called observers) can sign up to be notified when that data arrives (called subscribing). So, whenever our observable recieves its data, it will broadcast that information out and the observers will be listening for it.  </p>\n<p>Some key points to note about the pattern:</p>\n<ul>\n<li>You can have one observable and many observers (a one-to-many dependancy). That is, one broadcaster and an unlimited number of recipients.</li>\n<li>When that observable changes, all observers should be updated/notified immediately and automatically</li>\n<li>It is the observer&#39;s responsibility to register and unregister themselves from the observable (to be notified of changes) and to update their own state when notified.</li>\n</ul>\n<h2 id=\"so-an-observable-\">So... an Observable?</h2>\n<p>Think of an observable as a box that you create to hold data from a service or function whose data or items will arrive over time. </p>\n<p>As the data arrives, the box notifies anyone that has requested they be updated and it does so in the way they&#39;ve asked.</p>\n<h2 id=\"basic-structure\">Basic structure</h2>\n<p>In its simpliest form, an Observable is a function that accepts an object (an observer) with next, error and complete methods on it. </p>\n<p>When you create an observable, you call its constructor and pass in a function. That function takes in an observer as a parameter and its body contains instructions for when to call each of the observer&#39;s methods. </p>\n<p>For example:</p>\n<pre><code class=\"lang-javascript\">const data = Observable.create(observer =&gt; {\n  setTimeout(() =&gt; observer.next(&#39;first&#39;), 1000);\n  setTimeout(() =&gt; observer.complete(), 3000);\n});\n</code></pre>\n<p>The newly created observable doesn&#39;t actually do anything until: </p>\n<ul>\n<li>a) someone subscribes and passes in an observer and </li>\n<li>b) data is emitted.</li>\n</ul>\n<p>When you subscribe to an observable, this is the equivilant to calling the observable like a function and passing in an observer. This tells the observerable that you&#39;d like to be notified when data arrives, and tells it which functions to run (via the observer object) to do that.</p>\n<pre><code class=\"lang-javascript\">this.data\n    .subscribe({\n        next: console.log,\n        error: console.error,\n        complete: () =&gt; console.info(&#39;complete&#39;)\n    });\n</code></pre>\n<p>Our observer contains 1 to 3 functions to be executed by the observable:</p>\n<ul>\n<li>next: function that will be executed each time a value is emitted (mandatory) </li>\n<li>error: function that will be executed when an error is emitted (optional)</li>\n<li><p>complete: function that will be executed when a &#39;completed&#39; is emitted (optional)</p>\n<p>```javascript\nthis.data\n .subscribe(myObserver);</p>\n</li>\n</ul>\n<p>const myObserver = {\n    next: console.log,\n    error: console.error,\n    complete: () =&gt; console.info(&#39;complete&#39;)\n}\n```</p>\n<p>Those functions you pass in as part of the observer object will stay active and listen for those events until you manually decide to unsubscribe from and stop listening to the observable.</p>\n<p>Note: <code>error</code> and <code>complete</code> are optional. But when these functions are called, they will trigger the unsubscription logic and the observer will stop listening to the observable. So if there is an error, the complete won&#39;t fire and vice versa.</p>\n<p>When you subscribe, the observable sets up your observer with the functions you pass in and, when it emits, it&#39;ll call those functions.</p>\n<h2 id=\"basic-example\">Basic example</h2>\n<p><a href=\"https://jsbin.com/penicovixi/edit?js,console\">Open in JSbin</a></p>\n<p><em>(example by Philip Da Silva)</em></p>\n<h2 id=\"how-do-observables-compare-\">How do Observables compare?</h2>\n<p>Callbacks:</p>\n<ul>\n<li>Not as scalable and they often can become overly nested (pyramid of doom)</li>\n</ul>\n<p>Promises:</p>\n<ul>\n<li>Good for one piece of data but they aren&#39;t as helpful for managing collections of data over time. For example, when you expect one value from a server and then for that promise to be fulfilled. </li>\n<li>They also aren&#39;t cancellable - they are always listening.</li>\n</ul>\n<p>Observables:</p>\n<ul>\n<li>Allow us to work with complex data over time (streams)</li>\n<li>Are cancellable</li>\n<li>Are compositional (you can build on them) and they are lazy (they do not start emitting data until an observer has subscribed)</li>\n<li>Allows us to chain together array-like operators and pass observable streams through to parse, modify and maintain the data within them. We&#39;ll look at these next.</li>\n</ul>\n<h2 id=\"resources\">Resources</h2>\n<ul>\n<li><a href=\"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\">The introduction to Reactive Programming you&#39;ve been missing</a></li>\n<li><a href=\"https://xgrommx.github.io/rx-book/why_rx.html\">RxBook</a></li>\n<li><a href=\"https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87\">Learning Observable By Building Observable</a></li>\n<li><a href=\"https://developer.telerik.com/topics/web-development/introduction-observables-angular-developers/\">An Introduction to Observables for Angular Developers</a></li>\n<li><a href=\"https://angular-2-training-book.rangle.io/handout/observables/\">Angular 2 Training: Observables</a></li>\n<li><a href=\"https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\">Hot vs Cold Observables</a></li>\n<li><a href=\"http://blog.rangle.io/observables-and-reactive-programming-in-angular-2/\">Observables and Reactive Programming in Angular 2</a></li>\n<li><a href=\"https://www.learnrxjs.io/\">Learn RxJS</a></li>\n<li><a href=\"http://reactivex.io/rxjs/\">RxJS</a></li>\n</ul>\n"}},"siteProps":{"title":"React Static"}};</script><script async="" src="/app.2d308331.js"></script></body></html>