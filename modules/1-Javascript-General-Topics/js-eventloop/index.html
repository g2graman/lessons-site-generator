<!DOCTYPE html><html lang="en-US" data-reactroot=""><head><title data-react-helmet="true"></title><link rel="stylesheet" href="https://g2graman.github.io/lessons-site-generator/styles.2d308331.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css"/><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:500"/></head><body><div class="slug-home"><div id="root"><div data-reactroot=""><header class=" mdc-toolbar"><div class=" mdc-toolbar__row"><section class="brand  mdc-toolbar__section mdc-toolbar__section--align-start"><svg width="48" height="48" viewBox="0 0 1205 863" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>white bridge logo</title><desc>white bridge logo</desc><use xlink:href="#a" transform="translate(0 485.01)" fill="#FAFAFA"></use><use xlink:href="#b" transform="translate(246.1 572.65)" fill="#FAFAFA"></use><use xlink:href="#c" transform="translate(412.5 486)" fill="#FAFAFA"></use><use xlink:href="#d" transform="translate(522.1 486)" fill="#FAFAFA"></use><use xlink:href="#e" transform="translate(768.2 573.64)" fill="#FAFAFA"></use><use xlink:href="#f" transform="translate(1013.3 573.64)" fill="#FAFAFA"></use><g><use xlink:href="#g" transform="translate(198.3 1)" fill="#FAFAFA"></use><use xlink:href="#h" transform="translate(859.9)" fill="#FAFAFA"></use><use xlink:href="#i" transform="translate(382.6)" fill="#FAFAFA"></use><use xlink:href="#j" transform="translate(381.6 106.56)" fill="#FAFAFA"></use></g><defs><path id="a" d="M57.792 297.776H0V0h57.792v110.546c8.967-10.955 29.892-21.91 50.816-21.91 59.785 0 92.666 48.799 92.666 107.557 0 58.759-33.878 106.562-92.666 106.562-21.92 0-42.845-10.955-50.816-21.91v16.931zm0-68.718c6.974 13.943 21.92 23.902 37.863 23.902 30.889 0 48.824-24.898 48.824-57.763 0-32.864-17.935-57.762-48.824-57.762-15.942 0-31.885 9.959-37.863 23.902v67.721z"></path><path id="b" d="M125.547 61.746c-7.971-4.98-17.935-6.971-28.895-6.971-18.932 0-34.875 9.959-39.857 28.881v126.48H0V4.98h56.795v19.918C65.763 9.959 82.702 0 102.63 0c9.964 0 17.935 1.992 21.921 2.988l.996 58.758z"></path><path id="c" d="M33.878 65.73C15.943 65.73 0 52.783 0 32.865 0 14.939 14.946 0 33.878 0c17.935 0 33.878 12.947 33.878 32.865-.997 19.918-16.94 32.865-33.878 32.865zm27.9 231.05H4.981V92.62h56.795v204.16z"></path><path id="d" d="M143.483 279.849c-8.968 10.955-29.893 21.91-50.817 21.91C32.88 301.759 0 253.956 0 195.197 0 136.439 33.878 87.64 92.666 87.64c21.921 0 42.845 10.955 50.817 21.91V0h57.791v297.776h-57.791v-17.927zm0-118.512c-6.975-12.947-21.921-23.902-37.864-23.902-30.888 0-48.824 24.897-48.824 57.762s17.936 57.763 48.824 57.763c16.939 0 31.885-9.959 37.864-23.902v-67.721z"></path><path id="e" d="M142.486 184.242c-8.967 10.955-27.899 20.914-49.82 20.914C32.882 205.156 0 157.353 0 102.578 0 47.803 33.878 0 92.666 0c22.917 0 40.853 9.959 49.82 19.918V3.984h56.795v182.25c0 69.714-42.845 102.578-100.637 102.578-52.81 0-89.676-26.889-95.655-72.701h54.803c4.982 18.923 17.935 28.882 39.856 28.882 28.896 0 43.842-16.931 43.842-49.796l.996-10.955zm0-115.524c-6.975-11.951-21.921-20.915-37.863-20.915-30.889 0-47.828 22.906-47.828 54.775s17.936 54.775 47.828 54.775c16.939 0 31.885-9.959 37.863-21.91V68.717z"></path><path id="f" d="M190.314 142.414c-7.972 42.824-39.857 71.706-90.673 71.706C39.856 214.12 0 171.296 0 107.558 0 44.816 40.853 0 98.644 0c60.781 0 92.666 40.832 92.666 101.582v16.931H54.802c1.993 30.873 18.932 48.799 43.842 48.799 18.932 0 33.878-7.967 37.864-25.893l53.806.995zM56.795 84.652h78.716c0-21.91-12.953-37.844-36.867-37.844-21.92 0-37.863 12.946-41.849 37.844z"></path><path id="g" d="M85.69 302.755c0 8.963 4.983 13.943 13.95 13.943h46.832v42.824H99.641c-36.867 0-62.774-23.902-62.774-60.75V214.12c0-8.964-4.982-13.943-13.95-13.943H0v-43.82h23.914c8.967 0 13.95-4.979 13.95-13.943V60.75C37.863 22.906 63.77 0 100.636 0h45.835v42.824H99.641c-8.968 0-13.95 4.98-13.95 13.943v80.668c0 20.914-9.964 31.869-22.917 39.836 12.953 7.967 22.917 18.922 22.917 39.836v85.648z"></path><path id="h" d="M60.78 217.107c0-20.914 9.965-31.869 22.918-39.836-12.953-7.967-22.917-18.922-22.917-39.836V55.771c0-8.963-4.982-13.943-13.95-13.943H0V0h45.835c36.867 0 62.773 23.902 62.773 60.75v79.673c0 8.963 4.982 13.942 13.95 13.942h23.914v44.816h-23.914c-8.968 0-13.95 4.98-13.95 13.943v84.652c0 37.844-25.906 60.75-62.773 60.75H0v-42.824h46.831c8.968 0 13.95-4.98 13.95-13.943v-84.652z"></path><path id="i" d="M220.206 0H0v41.828H439.415V0H220.206z"></path><path id="j" d="M374.649 210.136v-59.754C374.649 65.73 307.89 0 222.199 0h-3.986c-85.691 0-152.45 65.73-152.45 150.382v59.754H0v42.824h107.612V151.378c0-60.75 48.824-108.554 110.601-108.554h3.986c61.777 0 110.601 47.803 110.601 108.554V252.96h107.612v-42.824h-65.763z"></path></defs></svg></section><section class="navigation  mdc-toolbar__section"><nav><a href="https://g2graman.github.io/lessons-site-generator/">Modules</a><a href="https://g2graman.github.io/lessons-site-generator/about">About</a></nav></section></div></header><div class="content"><div><a href="https://g2graman.github.io/lessons-site-generator/"><button class=" mdc-button mdc-button--stroked">Back to Modules</button></a><br/><h3>Js Eventloop</h3><p><h1 id="the-javascript-event-loop">The JavaScript Event Loop</h1>
<h2 id="what-is-it-">What is it?</h2>
<p>Modern browsers have JavaScript engines that handle executing JavaScript using a model called the event loop. The event loop runs on a single thread - it only works on one thing at a time. It consist of three parts: stack, heap, and queue.</p>
<p><a href="https://postimg.org/image/1759o89x23/"><img src="https://s1.postimg.org/3k7w5fnq8v/async----event_loop.jpg" alt="async----event_loop.jpg"></a></p>
<p>The basic idea is: during runtime, there are messages/tasks that are being created, lining up in a queue, and being processed one by one by the JavaScript engine. When a message is being processed, it uses the stack and heap to manage stuff the stuff it&#39;s doing - kind of like its own personal workspace. While a message is being processed, it may create other messages to be put into the queue. </p>
<h3 id="heap">Heap</h3>
<p>The heap is just a mostly unstructured region where memory for objects is allocated. </p>
<h3 id="stack">Stack</h3>
<p>The stack manages function calls at runtime. You can think of it as stacked <em>frames</em>, where each frame is a reference to a spot in some function scope. A frame is created when a function is called, and is removed when that function has completed. It might be helpful to think of a stack of blocks: the most immediate block you&#39;re dealing with is always the top block. That is, you add and remove blocks from the top (unless you&#39;re playing a game of Jenga).</p>
<p>Below is a great example taken from <a href="http://exploringjs.com/es6/ch_async.html#sec_javascript-call-stack">Exploring JS</a> to demonstrate the stack.</p>
<p>Let&#39;s look at this code:</p>
<pre><code>function h(z) {
    // Print stack trace
    console.log(new Error().stack); // (A)
}
function g(y) {
    h(y + 1); // (B)
}
function f(x) {
    g(x + 1); // (C)
}
f(3); // (D)
return; // (E)
</code></pre><p>Initially, when the program above is started, the call stack is empty. After the function call f(3) in line D, the stack has one entry:</p>
<pre><code>|----------|
| Location |
| in global|
| scope    |
|----------|
</code></pre><p>After the function call g(x + 1) in line C, the stack has two entries:</p>
<pre><code>|----------|
| Location |
|  in f    |
|          |
|----------|
| Location |
| in global|
| scope    |
|----------|
</code></pre><p>After the function call h(y + 1) in line B, the stack has three entries:</p>
<pre><code>|----------|
| Location |
|  in g    |
|          |
|----------|
| Location |
|  in f    |
|          |
|----------|
| Location |
| in global|
| scope    |
|----------|
</code></pre><p>The stack trace printed in line A shows you what the call stack looks like:</p>
<pre><code>Error
    at h (stack_trace.js:2:17)
    at g (stack_trace.js:6:5)
    at f (stack_trace.js:9:5)
    at &lt;global&gt; (stack_trace.js:11:1)
</code></pre><p>Next, each of the functions terminates and each time, the top entry is removed from the stack. After function f is done, we are back in global scope and the call stack is empty. In line E we return and the stack is empty, which means that the program terminates.</p>
<h3 id="queue">Queue</h3>
<p>The queue is a place where messages line up to be processed during runtime. A message is like a task item (sidenote: they are often called tasks). Every message has an associated function. A message is processed when:</p>
<ol>
<li>It is at the front of the queue (first in line) </li>
<li>The previous message is completely done being processed</li>
</ol>
<p>Only one message is processed at a time. The processing consists of calling the associated function, which creates the initial stack frame. That function will do its business and eventually complete aka be terminated and removed from the stack. The processing is completed when the stack is empty again.</p>
<h2 id="when-are-messages-added-to-the-queue-">When are messages added to the queue?</h2>
<p>There are various things during runtime that are added to the queue as messages (for example, reaction to user input such as click). In the case of asynchronous tasks: if an async task is called and has an associated callback function, a message with the associated callback function will be put at the <strong>end</strong> of the queue <strong>after</strong> the task has completed and returned. That means the callback function will never be executed before the current message (the one that called the async task), is completed.</p>
<h2 id="an-example">An example</h2>
<p>Let&#39;s look at an example. When you run this JS code, what do you expect to see in your console (in what order will the statements print)?</p>
<pre><code class="lang-javascript">console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;hello!&#39;);
}, 0);

console.log(&#39;script end&#39;);
</code></pre>
<p><a href="https://repl.it/OBrd/0">Try it out yourself</a></p>
<p>It turns out they print in this order:</p>
<pre><code>script start
script end
hello!
</code></pre><p>Why doesn&#39;t <code>hello!</code> print before <code>script end</code> if the <code>setTimeout</code> comes before the last <code>console.log</code> and has a delay of 0 milliseconds?</p>
<p><code>setTimeout</code> is an asynchronous function. The delay you give it does not set the amount of time before the callback function executes, but rather, the minimum amount of time before the callback function can be added to the queue. Remember that only one message can be processed at a time and it must complete before the next message is processed.</p>
<p>So in this example, this program starts and is on the call stack. <code>console.log</code> is executed synchronously so it logs &#39;script start&#39;. Then comes the <code>setTimeout</code> which puts the logging callback function into the queue. The current program continues, logging &#39;script end&#39;. Then it is completed and popped off the stack - the message is terminated. Only then can the next message in the queue (the callback that logs &#39;hello!&#39;) be processed. </p>
</p></div></div></div></div></div><script type="text/javascript">
                window.__routeData = {"path":"/modules/1-Javascript-General-Topics/js-eventloop","propsMap":{"__local":"Z1xHtOX"},"initialProps":{"module":{"contents":{"data":{}},"title":"Js Eventloop","path":"1-Javascript-General-Topics/js-eventloop","id":"js-eventloop","body":"<h1 id=\"the-javascript-event-loop\">The JavaScript Event Loop</h1>\n<h2 id=\"what-is-it-\">What is it?</h2>\n<p>Modern browsers have JavaScript engines that handle executing JavaScript using a model called the event loop. The event loop runs on a single thread - it only works on one thing at a time. It consist of three parts: stack, heap, and queue.</p>\n<p><a href=\"https://postimg.org/image/1759o89x23/\"><img src=\"https://s1.postimg.org/3k7w5fnq8v/async----event_loop.jpg\" alt=\"async----event_loop.jpg\"></a></p>\n<p>The basic idea is: during runtime, there are messages/tasks that are being created, lining up in a queue, and being processed one by one by the JavaScript engine. When a message is being processed, it uses the stack and heap to manage stuff the stuff it&#39;s doing - kind of like its own personal workspace. While a message is being processed, it may create other messages to be put into the queue. </p>\n<h3 id=\"heap\">Heap</h3>\n<p>The heap is just a mostly unstructured region where memory for objects is allocated. </p>\n<h3 id=\"stack\">Stack</h3>\n<p>The stack manages function calls at runtime. You can think of it as stacked <em>frames</em>, where each frame is a reference to a spot in some function scope. A frame is created when a function is called, and is removed when that function has completed. It might be helpful to think of a stack of blocks: the most immediate block you&#39;re dealing with is always the top block. That is, you add and remove blocks from the top (unless you&#39;re playing a game of Jenga).</p>\n<p>Below is a great example taken from <a href=\"http://exploringjs.com/es6/ch_async.html#sec_javascript-call-stack\">Exploring JS</a> to demonstrate the stack.</p>\n<p>Let&#39;s look at this code:</p>\n<pre><code>function h(z) {\n    // Print stack trace\n    console.log(new Error().stack); // (A)\n}\nfunction g(y) {\n    h(y + 1); // (B)\n}\nfunction f(x) {\n    g(x + 1); // (C)\n}\nf(3); // (D)\nreturn; // (E)\n</code></pre><p>Initially, when the program above is started, the call stack is empty. After the function call f(3) in line D, the stack has one entry:</p>\n<pre><code>|----------|\n| Location |\n| in global|\n| scope    |\n|----------|\n</code></pre><p>After the function call g(x + 1) in line C, the stack has two entries:</p>\n<pre><code>|----------|\n| Location |\n|  in f    |\n|          |\n|----------|\n| Location |\n| in global|\n| scope    |\n|----------|\n</code></pre><p>After the function call h(y + 1) in line B, the stack has three entries:</p>\n<pre><code>|----------|\n| Location |\n|  in g    |\n|          |\n|----------|\n| Location |\n|  in f    |\n|          |\n|----------|\n| Location |\n| in global|\n| scope    |\n|----------|\n</code></pre><p>The stack trace printed in line A shows you what the call stack looks like:</p>\n<pre><code>Error\n    at h (stack_trace.js:2:17)\n    at g (stack_trace.js:6:5)\n    at f (stack_trace.js:9:5)\n    at &lt;global&gt; (stack_trace.js:11:1)\n</code></pre><p>Next, each of the functions terminates and each time, the top entry is removed from the stack. After function f is done, we are back in global scope and the call stack is empty. In line E we return and the stack is empty, which means that the program terminates.</p>\n<h3 id=\"queue\">Queue</h3>\n<p>The queue is a place where messages line up to be processed during runtime. A message is like a task item (sidenote: they are often called tasks). Every message has an associated function. A message is processed when:</p>\n<ol>\n<li>It is at the front of the queue (first in line) </li>\n<li>The previous message is completely done being processed</li>\n</ol>\n<p>Only one message is processed at a time. The processing consists of calling the associated function, which creates the initial stack frame. That function will do its business and eventually complete aka be terminated and removed from the stack. The processing is completed when the stack is empty again.</p>\n<h2 id=\"when-are-messages-added-to-the-queue-\">When are messages added to the queue?</h2>\n<p>There are various things during runtime that are added to the queue as messages (for example, reaction to user input such as click). In the case of asynchronous tasks: if an async task is called and has an associated callback function, a message with the associated callback function will be put at the <strong>end</strong> of the queue <strong>after</strong> the task has completed and returned. That means the callback function will never be executed before the current message (the one that called the async task), is completed.</p>\n<h2 id=\"an-example\">An example</h2>\n<p>Let&#39;s look at an example. When you run this JS code, what do you expect to see in your console (in what order will the statements print)?</p>\n<pre><code class=\"lang-javascript\">console.log(&#39;script start&#39;);\n\nsetTimeout(function() {\n  console.log(&#39;hello!&#39;);\n}, 0);\n\nconsole.log(&#39;script end&#39;);\n</code></pre>\n<p><a href=\"https://repl.it/OBrd/0\">Try it out yourself</a></p>\n<p>It turns out they print in this order:</p>\n<pre><code>script start\nscript end\nhello!\n</code></pre><p>Why doesn&#39;t <code>hello!</code> print before <code>script end</code> if the <code>setTimeout</code> comes before the last <code>console.log</code> and has a delay of 0 milliseconds?</p>\n<p><code>setTimeout</code> is an asynchronous function. The delay you give it does not set the amount of time before the callback function executes, but rather, the minimum amount of time before the callback function can be added to the queue. Remember that only one message can be processed at a time and it must complete before the next message is processed.</p>\n<p>So in this example, this program starts and is on the call stack. <code>console.log</code> is executed synchronously so it logs &#39;script start&#39;. Then comes the <code>setTimeout</code> which puts the logging callback function into the queue. The current program continues, logging &#39;script end&#39;. Then it is completed and popped off the stack - the message is terminated. Only then can the next message in the queue (the callback that logs &#39;hello!&#39;) be processed. </p>\n"}},"siteProps":{"title":"React Static"}};</script><script async="" src="/app.2d308331.js"></script></body></html>